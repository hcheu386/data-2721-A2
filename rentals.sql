drop database if exists rentals;
create database rentals;
use rentals;



create function date_overlap (start_1 date, end_1 date, start_2 date, end_2 date)
returns bool
deterministic
return
    (start_1 >= start_2 and start_1 <= end_2)
    or (end_1 >= start_2 and end_1 <= end_2);


create table person (
    id int auto_increment,
    first_name varchar(30),
    middle_name varchar(30),
    last_name varchar(30),
    full_name varchar(90) as (concat_ws(' ', first_name, middle_name, last_name)),
    -- max length of phone number according to ITU-T E.164
    phone bigint check (phone <= 999999999999999 and phone >= 0) not null,
    -- length according to https://www.rfc-editor.org/rfc/rfc5321.txt
    email_local varchar(64),
    email_domain varchar(255),
    email varchar(320) as (concat(email_local, '@', email_domain)),
    primary key (id)
);

create table guarantor (
    id int,
    ord tinyint not null,
    guarantor int not null,
    primary key (id, ord),
    foreign key (id) references person(id),
    foreign key (guarantor) references person(id)
);

create table building (
    id int auto_increment,
    manager int,
    addr varchar(100) not null,
    name varchar(50),
    description varchar(1000),
    primary key (id),
    foreign key (manager) references person(id)
);

create table apartment (
    building int,
    num varchar(4),
    type varchar(30),
    description varchar(1000),
    primary key (building, num),
    foreign key (building) references building(id)
);

create table lease_type (
    id tinyint auto_increment,
    name varchar(30) not null,
    days_per_term smallint not null,
    primary key (id)
);
insert into lease_type (name, days_per_term) values
('long term', 365),
('fixed term', 30),
('short term', 1);

create table lease (
    building int,
    apartment varchar(4),
    start_date date,
    lease_type tinyint not null,
    minimum_term smallint not null,
    rent_per_term int not null,
    primary key (building, apartment, start_date),
    foreign key (building, apartment) references apartment(building, num),
    foreign key (lease_type) references lease_type(id)
);

create table tenant (
    building int,
    apartment varchar(4),
    start_date date,
    ord tinyint,
    tenant int not null,
    primary key (building, apartment, start_date, ord),
    foreign key (building, apartment, start_date) references lease(building, apartment, start_date),
    foreign key (tenant) references person(id)
);


delimiter $
create trigger date_overlap before insert on lease for each row
begin
    declare days int;

    select days_per_term into days from lease_type where new.lease_type = id;

    if exists (
        select true from lease l, lease_type t
        where l.lease_type = t.id
        and l.building = new.building
        and l.apartment = new.apartment
        and date_overlap(
            new.start_date,
            date_add(new.start_date, interval new.minimum_term * days day),
            l.start_date,
            date_add(l.start_date, interval l.minimum_term * t.days_per_term day)
        ) limit 1
    ) then
        signal sqlstate value '23000' set message_text = 'The date of the input lease overlaps with existing lease(s) of the same apartment.';
    end if;
end $
delimiter ;


-- Task 3
-- Retrieve the details of all apartments in a specific building, sorted by apartment type.
SELECT *
FROM apartment
WHERE building = 1  
ORDER BY type;

-- Find all available apartments (not booked during a given date range). 
SELECT a.*
FROM apartment a
WHERE NOT EXISTS (
    SELECT 1
    FROM lease l
    JOIN lease_type lt ON l.lease_type = lt.id
    WHERE l.building = a.building
      AND l.apartment = a.num
      And date_overlap(
      l.start_date,  
      DATE_ADD(l.start_date, INTERVAL l.minimum_term * lt.days_per_term DAY),
            '2025-01-01',
            '2025-01-31'
          )
);

-- List the buildings with the highest number of booked apartments. 
SELECT b.name, COUNT(l.apartment) AS booked_apartments
FROM building b
JOIN lease l ON b.id = l.building
GROUP BY b.id
ORDER BY booked_apartments DESC;

-- Retrieve the total revenue generated by each building from bookings (assume booking cost =  $100 per day). 
SELECT b.name, SUM(l.minimum_term * l.days_per_term * 100) AS total_revenue
FROM building b
JOIN lease l ON b.id = l.building
JOIN lease_type lt ON l.lease_type = lt.id
GROUP BY b.id;

-- Find guests who have made more than 2 bookings. 
SELECT p.full_name, COUNT(t.tenant) AS booking_count
FROM person p
JOIN tenant t ON p.id = t.tenant
GROUP BY p.id
HAVING booking_count > 2;

-- List all bookings that are currently active (ongoing based on the current date). 
SELECT l.*
FROM lease l
JOIN lease_type lt ON l.lease_type = lt.id
WHERE l.start_date <= '2025-06-15'
  AND DATE_ADD(l.start_date, INTERVAL l.minimum_term * lt.days_per_term DAY) >= '2025-06-15';

-- Generate a report showing booking details (apartment, guest name, booking status) for a specific  date range. 
SELECT 
    a.building AS building_id,
    a.num AS apartment_number,
    p.full_name AS guest_name,
    CASE 
        WHEN l.start_date <= '2025-12-31' AND DATE_ADD(l.start_date, INTERVAL l.minimum_term * lt.days_per_term DAY) >= '2025-01-01' THEN 'Active'
        ELSE 'Inactive'
    END AS booking_status
    FROM lease l
JOIN lease_type lt ON l.lease_type = lt.id
JOIN apartment a ON l.building = a.building AND l.apartment = a.num
JOIN tenant t ON l.building = t.building AND l.apartment = t.apartment AND l.start_date = t.start_date
JOIN person p ON t.tenant = p.id
WHERE l.start_date <= '2025-12-31'
  AND DATE_ADD(l.start_date, INTERVAL l.minimum_term * lt.days_per_term DAY) >= '2025-01-01';
